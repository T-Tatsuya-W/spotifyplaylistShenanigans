<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Spotify CSV Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7f9;
      --card: #fff;
      --border: #e2e5ea;
      --radius: 14px;
      --pad: 18px;
      --muted: #5d6470;
      --accent: #1db954;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: #10121a;
      min-height: 100vh;
    }

    main.app {
      margin: 0 auto;
      max-width: 1120px;
      padding: 28px 20px 80px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    header.app-header {
      display: grid;
      gap: 12px;
    }

    header.app-header h1 {
      font-size: clamp(28px, 4vw, 36px);
      margin: 0;
    }

    header.app-header p {
      margin: 0;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: 0 18px 35px -30px rgba(20, 32, 45, 0.6);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 20px;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .section-title .action-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .muted { color: var(--muted); }

    .control-stack {
      display: grid;
      gap: 14px;
    }

    .control-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    label { font-weight: 600; font-size: 14px; }

    input[type="text"],
    input[type="search"],
    input[type="number"],
    button {
      font: inherit;
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 9px 13px;
      background: #fff;
    }

    button {
      background: #10121a;
      color: #fff;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px -12px rgba(16, 18, 26, 0.9);
    }

    .ghost-button {
      background: transparent;
      color: #10121a;
      border: 1px solid var(--border);
    }

    .ghost-button:not(:disabled):hover {
      background: rgba(16, 18, 26, 0.04);
    }

    .auth-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px 20px;
      margin-top: 6px;
      font-size: 14px;
    }

    .auth-bar input[type="text"] {
      min-width: min(260px, 100%);
    }

    .scatter-card {
      padding: 0;
      overflow: hidden;
    }

    .scatter-header {
      padding: var(--pad);
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .scatter-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .scatter-actions .status {
      font-size: 12px;
      color: var(--muted);
    }

    canvas#scatterPlot {
      width: 100%;
      height: auto;
      display: block;
      max-height: min(70vh, 580px);
      touch-action: none;
    }

    .scatter-label {
      color: var(--muted);
      font-size: 12px;
    }

    .scatter-tooltip {
      position: fixed;
      background: rgba(16, 18, 26, 0.92);
      color: #fff;
      padding: 8px 11px;
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      box-shadow: 0 14px 28px -18px rgba(16, 18, 26, 0.9);
      display: none;
      z-index: 20;
      max-width: clamp(180px, 50vw, 320px);
    }

    details.fold {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--card);
      padding: 0;
      overflow: hidden;
    }

    details.fold summary {
      list-style: none;
      cursor: pointer;
      padding: 16px 20px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    details.mini-fold {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #f9fafb;
      padding: 0;
      overflow: hidden;
    }

    details.mini-fold summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    details.fold[open] summary {
      border-bottom: 1px solid var(--border);
    }

    details.fold summary::after,
    details.mini-fold summary::after {
      content: "‚ñæ";
      font-size: 12px;
      opacity: 0.65;
      transition: transform 0.2s ease;
    }

    details.fold summary::-webkit-details-marker { display: none; }

    details.fold .fold-body {
      padding: 18px 20px 24px;
      display: grid;
      gap: 20px;
    }

    details.mini-fold[open] summary {
      border-bottom: 1px solid var(--border);
    }

    details.mini-fold summary::-webkit-details-marker { display: none; }

    details.fold[open] summary::after,
    details.mini-fold[open] summary::after {
      transform: rotate(180deg);
    }

    details.mini-fold .mini-fold-body {
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    details.mini-fold .mini-fold-body input[type="search"] {
      width: 100%;
    }

    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
    }

    .filter-card {
      display: grid;
      gap: 10px;
      padding: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(248,249,252,0.95));
    }

    .filter-card .range-values {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--muted);
    }

    .filter-card input[type="range"] {
      width: 100%;
    }

    .knn-grid {
      display: grid;
      gap: 12px;
      align-items: start;
    }

    .knn-dims {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .knn-dims .knn-dim-btn {
      border-radius: 14px;
      border: 1px solid var(--border);
      background: #fff;
      color: #10121a;
      padding: 12px 18px;
      min-width: 120px;
      text-align: center;
      font-weight: 600;
      transition: background 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
      flex: 1 1 140px;
      transform: none;
      box-shadow: none;
    }

    .knn-dims .knn-dim-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 10px 20px -15px rgba(29, 185, 84, 0.7);
    }

    .knn-dims .knn-dim-btn:not(:disabled):hover {
      transform: none;
    }

    .knn-dims .knn-dim-btn:focus-visible {
      outline: 3px solid rgba(29, 185, 84, 0.35);
      outline-offset: 2px;
    }

    .table-wrap {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    thead th {
      position: sticky;
      top: 0;
      background: #f9fafb;
      padding: 10px 12px;
      text-align: left;
      font-weight: 600;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
    }

    thead th:first-child { width: 42px; cursor: default; }

    thead th[data-sort]:not([data-sort=""])::after {
      content: attr(data-sort);
      margin-left: 6px;
      font-size: 11px;
      color: #9aa1ab;
    }

    tbody td {
      padding: 9px 12px;
      border-bottom: 1px solid #f1f3f6;
      vertical-align: top;
    }

    tbody tr:hover { background: #fafcff; }

    td.right { text-align: right; }

    a.link {
      color: #1b4bff;
      text-decoration: none;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; font-size: 13px; }

    #log {
      max-height: 220px;
      overflow-y: auto;
      font-size: 13px;
      display: grid;
      gap: 4px;
    }

    #log .ok { color: #087443; }
    #log .err { color: #a40000; }

    @media (max-width: 720px) {
      main.app { padding: 20px 14px 60px; }
      .control-row { flex-direction: column; align-items: stretch; }
      button, input { width: 100%; }
      header.app-header h1 { font-size: 26px; }
      .auth-bar { flex-direction: column; align-items: stretch; }
      .auth-bar > * { width: 100%; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" defer></script>
</head>
<body>
  <main class="app">
    <header class="app-header card">
      <div>
        <h1>Spotify CSV Browser</h1>
        <p>Load a CSV, explore tracks visually, and push your favourites into a Spotify playlist.</p>
      </div>
      <div class="auth-bar">
        <div class="control-row" style="gap: 10px 16px;">
          <button id="loginBtn">Log in with Spotify</button>
          <span id="authStatus" class="muted">Not logged in</span>
          <span class="muted">‚Ä¢</span>
          <span id="selectedCount" class="muted">No tracks selected</span>
        </div>
        <div class="control-row" style="gap: 12px;">
          <input id="playlistName" type="text" placeholder="Playlist name" value="PKCE Demo Playlist" />
          <button id="createPlaylistBtn" disabled>Create &amp; Add Selected Tracks</button>
        </div>
      </div>
    </header>

    <details class="fold" id="csvBrowserFold" open>
      <summary>
        CSV Browser
        <span class="muted" style="font-size: 12px;">Tip: double-click the scatter to grab similar songs.</span>
      </summary>
      <div class="fold-body">
        <div class="control-row">
          <label for="csvPath">CSV file</label>
          <input id="csvPath" type="text" class="mono" value="songs.csv" />
          <button id="loadCsvBtn">Load CSV</button>
        </div>
      </div>
    </details>

    <section class="card scatter-card">
      <div class="scatter-header">
        <div class="section-title">
          <h2>Energy vs. Valence</h2>
          <div class="action-group">
            <button id="resetFiltersBtn" type="button" class="ghost-button">Reset filters</button>
            <button id="deselectAllBtn" type="button" class="ghost-button">Deselect All</button>
          </div>
        </div>
        <div class="scatter-actions">
          <button id="scatterKnnBtn" type="button" disabled>Find neighbours</button>
          <span id="scatterSelectionLabel" class="status">Tap a point to enable neighbour search.</span>
        </div>
        <span class="scatter-label">Tap points to toggle selection ‚Ä¢ Double-tap (or use the button) to fetch KNN neighbours</span>
      </div>
      <canvas id="scatterPlot"></canvas>
      <div id="scatterTooltip" class="scatter-tooltip"></div>
    </section>

    <details class="fold" id="filtersFold" open>
      <summary>
        Filters &amp; Settings
        <span class="muted" style="font-size: 12px;">Refine the table or tweak the neighbour search.</span>
      </summary>
      <div class="fold-body">
        <div class="filters-grid" id="filtersContainer"></div>
        <div class="knn-grid">
          <div class="control-row" style="align-items: flex-end;">
            <label for="knnK">KNN neighbours (k)</label>
            <input id="knnK" type="number" min="1" max="50" value="5" style="width: 90px;" />
          </div>
          <div>
            <div class="muted" style="font-size: 12px; margin-bottom: 8px;">Dimensions</div>
            <div class="knn-dims" id="knnDimContainer"></div>
          </div>
        </div>
      </div>
    </details>

    <details class="fold" id="tableFold" open>
      <summary>
        Track List
        <span class="muted" style="font-size: 12px;">Tap a row to toggle selection. Use the headers to sort.</span>
      </summary>
      <div class="fold-body">
        <details class="mini-fold" id="tableSearchFold">
          <summary>Search tracks</summary>
          <div class="mini-fold-body">
            <input id="filterInput" type="search" placeholder="Search title, artist, or album" />
          </div>
        </details>
        <div class="control-row" style="justify-content: space-between;">
          <div class="control-row" style="gap: 10px;">
            <label class="muted" for="selectAll">Select visible</label>
            <input id="selectAll" type="checkbox" />
          </div>
        </div>
        <div class="table-wrap">
          <table id="csvTable">
            <thead>
              <tr>
                <th></th>
                <th data-key="Title" data-sort="">Title</th>
                <th data-key="Artist" data-sort="">Artist</th>
                <th data-key="Release" data-sort="">Release</th>
                <th data-key="BPM" data-sort="" class="right">BPM</th>
                <th data-key="Energy" data-sort="" class="right">Energy</th>
                <th data-key="Dance" data-sort="" class="right">Dance</th>
                <th data-key="Valence" data-sort="" class="right">Valence</th>
                <th data-key="Spotify_URL" data-sort="">Open</th>
              </tr>
            </thead>
            <tbody id="csvBody"></tbody>
          </table>
        </div>
      </div>
    </details>

    <details class="fold" id="logFold">
      <summary>
        Log
        <span class="muted" style="font-size: 12px;">We only surface errors and Spotify sync information here.</span>
      </summary>
      <div class="fold-body">
        <div id="log"></div>
      </div>
    </details>
  </main>

  <script>
    const CLIENT_ID = "2a1b848324a04242b06d3a1d0e5c16d9";
    const SCOPES = "playlist-modify-public playlist-modify-private user-read-private";
    const REDIRECT_URI = window.location.origin + window.location.pathname;

    const numericFields = ["BPM", "Energy", "Dance", "Valence"];
    const scatterFields = { x: "Energy", y: "Valence" };

    const dom = {
      log: document.getElementById("log"),
      authStatus: document.getElementById("authStatus"),
      selectedCount: document.getElementById("selectedCount"),
      playlistName: document.getElementById("playlistName"),
      createPlaylistBtn: document.getElementById("createPlaylistBtn"),
      loginBtn: document.getElementById("loginBtn"),
      csvPath: document.getElementById("csvPath"),
      loadCsvBtn: document.getElementById("loadCsvBtn"),
      filterInput: document.getElementById("filterInput"),
      selectAll: document.getElementById("selectAll"),
      deselectAllBtn: document.getElementById("deselectAllBtn"),
      resetFiltersBtn: document.getElementById("resetFiltersBtn"),
      csvBody: document.getElementById("csvBody"),
      tableHead: document.querySelector("#csvTable thead"),
      filtersContainer: document.getElementById("filtersContainer"),
      knnK: document.getElementById("knnK"),
      knnDimContainer: document.getElementById("knnDimContainer"),
      scatter: document.getElementById("scatterPlot"),
      scatterTooltip: document.getElementById("scatterTooltip"),
      scatterKnnBtn: document.getElementById("scatterKnnBtn"),
      scatterSelectionLabel: document.getElementById("scatterSelectionLabel")
    };

    const state = {
      rows: [],
      view: [],
      search: "",
      sort: { key: "Title", dir: "asc" },
      filters: {},
      knn: {
        k: 5,
        dimensions: {
          BPM: true,
          Energy: true,
          Dance: true,
          Valence: true
        }
      },
      selected: new Set(),
      scatter: {
        points: [],
        dirty: true,
        hoverId: null,
        lastActivatedId: null,
        lastTapId: null,
        lastTapTime: 0,
        skipNextDblClick: false
      }
    };

    function updateScatterKnnUi() {
      if (!dom.scatterKnnBtn || !dom.scatterSelectionLabel) return;
      const rowId = state.scatter.lastActivatedId;
      const isVisible = rowId !== null && state.view.some(row => row._idx === rowId);
      if (!isVisible) {
        dom.scatterKnnBtn.disabled = true;
        dom.scatterSelectionLabel.textContent = "Tap a point to enable neighbour search.";
        return;
      }
      const row = state.rows[rowId];
      if (!row) {
        dom.scatterKnnBtn.disabled = true;
        dom.scatterSelectionLabel.textContent = "Tap a point to enable neighbour search.";
        return;
      }
      dom.scatterKnnBtn.disabled = false;
      dom.scatterSelectionLabel.textContent = `${row.Title || "Unknown track"} ‚Äî ready for neighbours.`;
    }

    function setScatterFocus(rowId) {
      state.scatter.lastActivatedId = rowId;
      updateScatterKnnUi();
      scheduleScatterRender();
    }

    function log(msg, cls = "") {
      dom.log.style.display = "grid";
      const el = document.createElement("div");
      if (cls) el.className = cls;
      el.textContent = msg;
      dom.log.appendChild(el);
      dom.log.scrollTop = dom.log.scrollHeight;
    }

    function setAuthStatus(msg) {
      dom.authStatus.textContent = msg;
    }

    function generateRandomString(length) {
      const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      const values = crypto.getRandomValues(new Uint8Array(length));
      return Array.from(values, v => possible[v % possible.length]).join("");
    }

    async function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return crypto.subtle.digest("SHA-256", data);
    }

    function base64urlencode(bytes) {
      const str = String.fromCharCode(...new Uint8Array(bytes));
      return btoa(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }

    async function beginLogin() {
      const codeVerifier = generateRandomString(64);
      localStorage.setItem("code_verifier", codeVerifier);
      const codeChallenge = base64urlencode(await sha256(codeVerifier));
      const authUrl = new URL("https://accounts.spotify.com/authorize");
      authUrl.search = new URLSearchParams({
        response_type: "code",
        client_id: CLIENT_ID,
        scope: SCOPES,
        code_challenge_method: "S256",
        code_challenge: codeChallenge,
        redirect_uri: REDIRECT_URI,
        state: generateRandomString(16)
      }).toString();
      window.location.href = authUrl.toString();
    }

    async function exchangeCodeForToken(code) {
      const codeVerifier = localStorage.getItem("code_verifier");
      if (!codeVerifier) throw new Error("Missing code_verifier.");
      const body = new URLSearchParams({
        client_id: CLIENT_ID,
        grant_type: "authorization_code",
        code,
        redirect_uri: REDIRECT_URI,
        code_verifier: codeVerifier
      });
      const resp = await fetch("https://accounts.spotify.com/api/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error((data && data.error_description) || resp.statusText);
      localStorage.setItem("access_token", data.access_token);
      localStorage.setItem("refresh_token", data.refresh_token || "");
      return data.access_token;
    }

    async function apiFetch(path, options = {}) {
      const token = localStorage.getItem("access_token");
      if (!token) throw new Error("No access token.");
      const resp = await fetch(`https://api.spotify.com/v1${path}`, {
        ...options,
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json",
          ...(options.headers || {})
        }
      });
      if (resp.status === 401) throw new Error("Unauthorized (token expired?)");
      const text = await resp.text();
      try { return { ok: resp.ok, status: resp.status, json: JSON.parse(text) }; }
      catch { return { ok: resp.ok, status: resp.status, json: text }; }
    }

    function getNumericValue(val) {
      if (val === null || val === undefined || val === "") return null;
      const n = Number(String(val).replace(/[^0-9.\-]/g, ""));
      return Number.isFinite(n) ? n : null;
    }

    function escapeHTML(str) {
      return String(str ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function debounce(fn, wait = 160) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    let viewRefreshQueued = false;
    function scheduleViewRefresh() {
      if (viewRefreshQueued) return;
      viewRefreshQueued = true;
      requestAnimationFrame(() => {
        viewRefreshQueued = false;
        refreshView();
      });
    }

    let scatterRefreshQueued = false;
    function scheduleScatterRender(recompute = false) {
      if (recompute) state.scatter.dirty = true;
      if (scatterRefreshQueued) return;
      scatterRefreshQueued = true;
      requestAnimationFrame(() => {
        scatterRefreshQueued = false;
        renderScatter();
      });
    }

    function refreshView() {
      if (!state.rows.length) {
        dom.csvBody.innerHTML = "";
        state.view = [];
        state.scatter.lastActivatedId = null;
        updateScatterKnnUi();
        scheduleScatterRender(true);
        updateSelectedCount();
        return;
      }

      const q = state.search;
      const filters = state.filters;
      const filtered = [];

      for (const row of state.rows) {
        if (q && !row._haystack.includes(q)) continue;
        let passed = true;
        for (const field of numericFields) {
          const val = row._values[field];
          if (val === null) continue;
          const range = filters[field];
          if (val < range.min || val > range.max) {
            passed = false;
            break;
          }
        }
        if (passed) filtered.push(row);
      }

      const { key, dir } = state.sort;
      filtered.sort((a, b) => {
        const av = a[key];
        const bv = b[key];
        const an = getNumericValue(av);
        const bn = getNumericValue(bv);
        let cmp;
        if (an !== null && bn !== null) cmp = an - bn;
        else cmp = String(av ?? "").localeCompare(String(bv ?? ""), undefined, { numeric: true, sensitivity: "base" });
        return dir === "asc" ? cmp : -cmp;
      });

      state.view = filtered;
      if (state.scatter.lastActivatedId !== null && !filtered.some(row => row._idx === state.scatter.lastActivatedId)) {
        state.scatter.lastActivatedId = null;
      }
      renderTable();
      scheduleScatterRender(true);
      updateScatterKnnUi();
      updateSelectedCount();
    }

    function renderTable() {
      const rows = state.view;
      if (!rows.length) {
        dom.csvBody.innerHTML = `<tr><td colspan="9" class="muted">No rows match the current filters.</td></tr>`;
        updateSortIndicators();
        updateSelectAllState();
        return;
      }

      const html = rows.map(row => {
        const spotifyUrl = row.Spotify_URL || (row.Spotify_Track_ID ? `https://open.spotify.com/track/${row.Spotify_Track_ID}` : "");
        const checked = state.selected.has(row._idx) ? "checked" : "";
        return `<tr data-row-id="${row._idx}">
          <td><input type="checkbox" class="rowCheckbox" data-row-id="${row._idx}" ${checked} /></td>
          <td><button type="button" class="knn-btn" title="Find similar tracks">üîç</button> ${escapeHTML(row.Title)}</td>
          <td>${escapeHTML(row.Artist || row.Spotify_Artists)}</td>
          <td>${escapeHTML(row.Release || row.Spotify_Release_Date)}</td>
          <td class="right">${escapeHTML(row.BPM)}</td>
          <td class="right">${escapeHTML(row.Energy)}</td>
          <td class="right">${escapeHTML(row.Dance)}</td>
          <td class="right">${escapeHTML(row.Valence)}</td>
          <td>${spotifyUrl ? `<a class="link" href="${escapeHTML(spotifyUrl)}" target="_blank" rel="noopener">Open</a>` : ""}</td>
        </tr>`;
      }).join("");

      dom.csvBody.innerHTML = html;
      updateSortIndicators();
      updateSelectAllState();
    }

    function updateSortIndicators() {
      dom.tableHead.querySelectorAll("th[data-key]").forEach(th => {
        const key = th.dataset.key;
        th.dataset.sort = key === state.sort.key ? (state.sort.dir === "asc" ? "‚ñ≤" : "‚ñº") : "";
      });
    }

    function updateSelectAllState() {
      if (!state.view.length) {
        dom.selectAll.checked = false;
        dom.selectAll.indeterminate = false;
        return;
      }
      let checkedCount = 0;
      for (const row of state.view) {
        if (state.selected.has(row._idx)) checkedCount++;
      }
      if (checkedCount === 0) {
        dom.selectAll.checked = false;
        dom.selectAll.indeterminate = false;
      } else if (checkedCount === state.view.length) {
        dom.selectAll.checked = true;
        dom.selectAll.indeterminate = false;
      } else {
        dom.selectAll.checked = false;
        dom.selectAll.indeterminate = true;
      }
    }

    function updateSelectedCount() {
      const count = state.selected.size;
      dom.selectedCount.textContent = count ? `${count} track${count === 1 ? "" : "s"} selected` : "No tracks selected";
      if (count && localStorage.getItem("access_token")) {
        dom.createPlaylistBtn.disabled = false;
      } else if (!count) {
        dom.createPlaylistBtn.disabled = true;
      }
      state.scatter.points.forEach(point => {
        point.selected = state.selected.has(point.rowId);
      });
      scheduleScatterRender();
    }

    let filterListenersAttached = false;
    function buildFilters() {
      dom.filtersContainer.innerHTML = "";
      numericFields.forEach(field => {
        const range = state.filters[field];
        const wrapper = document.createElement("div");
        wrapper.className = "filter-card";
        wrapper.dataset.field = field;
        wrapper.innerHTML = `
          <div class="filter-label">${field}</div>
          <div class="range-values"><span data-role="min">${range.min}</span><span data-role="max">${range.max}</span></div>
          <input type="range" class="filter-slider" data-field="${field}" data-bound="min" min="${range.absoluteMin}" max="${range.absoluteMax}" value="${range.min}" step="1" />
          <input type="range" class="filter-slider" data-field="${field}" data-bound="max" min="${range.absoluteMin}" max="${range.absoluteMax}" value="${range.max}" step="1" />
        `;
        dom.filtersContainer.appendChild(wrapper);
      });
    }

    function attachFilterListeners() {
      if (filterListenersAttached) return;
      dom.filtersContainer.addEventListener("input", (event) => {
        const target = event.target;
        if (!target.classList.contains("filter-slider")) return;
        const field = target.dataset.field;
        const bound = target.dataset.bound;
        const value = Number(target.value);
        const range = state.filters[field];
        if (bound === "min") {
          range.min = Math.min(value, range.max);
        } else {
          range.max = Math.max(value, range.min);
        }
        updateFilterLabels(field);
        scheduleViewRefresh();
      });
      filterListenersAttached = true;
    }

    function updateFilterLabels(field) {
      const range = state.filters[field];
      const wrapper = dom.filtersContainer.querySelector(`.filter-card[data-field="${field}"]`);
      if (!wrapper) return;
      const minEl = wrapper.querySelector('[data-role="min"]');
      const maxEl = wrapper.querySelector('[data-role="max"]');
      if (minEl) minEl.textContent = range.min;
      if (maxEl) maxEl.textContent = range.max;
      wrapper.querySelectorAll(".filter-slider").forEach(slider => {
        const bound = slider.dataset.bound;
        slider.value = range[bound];
      });
    }

    function buildKnnControls() {
      dom.knnDimContainer.innerHTML = "";
      numericFields.forEach(field => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = `knn-dim-btn${state.knn.dimensions[field] ? " active" : ""}`;
        button.dataset.dim = field;
        button.textContent = field;
        button.setAttribute("aria-pressed", state.knn.dimensions[field] ? "true" : "false");
        dom.knnDimContainer.appendChild(button);
      });
    }

    function calculateDistance(rowA, rowB) {
      let sumSquares = 0;
      let activeCount = 0;
      for (const field of numericFields) {
        if (!state.knn.dimensions[field]) continue;
        const a = rowA._values[field];
        const b = rowB._values[field];
        if (a === null || b === null) continue;
        const { absoluteMin: min, absoluteMax: max } = state.filters[field];
        const span = max - min || 1;
        const normA = (a - min) / span;
        const normB = (b - min) / span;
        sumSquares += (normA - normB) ** 2;
        activeCount++;
      }
      return activeCount === 0 ? Infinity : Math.sqrt(sumSquares);
    }

    function findNearestNeighbors(rowId, exclude = new Set()) {
      const targetRow = state.rows[rowId];
      if (!targetRow) return [];
      const distances = state.rows.map((row, idx) => ({
        idx,
        distance: idx === rowId ? Infinity : calculateDistance(targetRow, row)
      }));
      const filtered = distances.filter(item => !exclude.has(item.idx));
      filtered.sort((a, b) => a.distance - b.distance);
      return filtered.slice(0, state.knn.k).map(item => item.idx);
    }

    function selectNeighbors(rowId) {
      const alreadySelected = new Set(state.selected);
      alreadySelected.add(rowId);
      const neighbors = findNearestNeighbors(rowId, alreadySelected);
      state.selected.add(rowId);
      let added = 0;
      neighbors.forEach(id => {
        if (!state.selected.has(id)) added++;
        state.selected.add(id);
      });
      updateSelectionCheckboxes();
      updateSelectedCount();
      log(`Added ${added} neighbouring track${added === 1 ? "" : "s"}.`, "ok");
    }

    function updateSelectionCheckboxes() {
      dom.csvBody.querySelectorAll(".rowCheckbox").forEach(cb => {
        const rowId = Number(cb.dataset.rowId);
        cb.checked = state.selected.has(rowId);
      });
      updateSelectAllState();
    }

    function toggleSelection(rowId) {
      if (state.selected.has(rowId)) state.selected.delete(rowId);
      else state.selected.add(rowId);
      updateSelectionCheckboxes();
      updateSelectedCount();
    }
    function computeScatterPoints() {
      const canvas = dom.scatter;
      const dpr = window.devicePixelRatio || 1;
      const width = canvas.clientWidth || canvas.parentElement.clientWidth || 520;
      const size = Math.min(width, 720);
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      canvas.style.height = `${size}px`;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const padding = 42;
      const plotSize = size - padding * 2;
      const rangeX = state.filters[scatterFields.x] || { absoluteMin: 0, absoluteMax: 100 };
      const rangeY = state.filters[scatterFields.y] || { absoluteMin: 0, absoluteMax: 100 };
      const spanX = rangeX.absoluteMax - rangeX.absoluteMin || 1;
      const spanY = rangeY.absoluteMax - rangeY.absoluteMin || 1;

      const points = [];
      state.view.forEach((row, idx) => {
        const xVal = row._values[scatterFields.x];
        const yVal = row._values[scatterFields.y];
        if (xVal === null || yVal === null) return;
        const x = padding + ((xVal - rangeX.absoluteMin) / spanX) * plotSize;
        const y = size - padding - ((yVal - rangeY.absoluteMin) / spanY) * plotSize;
        points.push({
          x,
          y,
          rowId: row._idx,
          label: `${row.Title} ‚Ä¢ ${row.Artist || row.Spotify_Artists || "Unknown"}`,
          selected: state.selected.has(row._idx),
          idx
        });
      });

      state.scatter.points = points;
      state.scatter.dirty = false;
      return { ctx, size, padding };
    }

    function renderScatter() {
      if (!dom.scatter) return;
      let ctx, size, padding;
      if (state.scatter.dirty) {
        ({ ctx, size, padding } = computeScatterPoints());
      } else {
        const dpr = window.devicePixelRatio || 1;
        size = dom.scatter.height / dpr || dom.scatter.clientWidth || 520;
        padding = 42;
        ctx = dom.scatter.getContext("2d");
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      const points = state.scatter.points;

      ctx.clearRect(0, 0, size, size);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, size, size);

      ctx.strokeStyle = "#e5e9ef";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, size - padding);
      ctx.lineTo(size - padding, size - padding);
      ctx.stroke();

      ctx.strokeStyle = "#f1f3f6";
      ctx.fillStyle = "#9ca3af";
      ctx.font = "11px system-ui";
      ctx.textAlign = "center";
      const gridSpan = size - padding * 2;
      for (let i = 0; i <= 100; i += 20) {
        const x = padding + (i / 100) * gridSpan;
        ctx.beginPath();
        ctx.moveTo(x, size - padding);
        ctx.lineTo(x, padding);
        ctx.stroke();
        ctx.fillText(i, x, size - padding + 16);
      }
      ctx.save();
      ctx.translate(12, size / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Valence", 0, 0);
      ctx.restore();
      ctx.fillText("Energy", size / 2, size - 12);

      points.forEach(point => {
        ctx.beginPath();
        const isHover = point.rowId === state.scatter.hoverId;
        const isFocused = point.rowId === state.scatter.lastActivatedId;
        const radius = isFocused ? 9 : isHover ? 8 : 6;
        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = point.selected ? "#1db954" : "rgba(16,18,26,0.65)";
        ctx.globalAlpha = isHover || isFocused ? 1 : 0.85;
        ctx.fill();
        if (isFocused) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = point.selected ? "#0d7a3a" : "#1db954";
          ctx.stroke();
        }
      });
      ctx.globalAlpha = 1;
    }

    function findPointAt(x, y) {
      let best = null;
      let minDist = 10;
      for (const point of state.scatter.points) {
        const dist = Math.hypot(point.x - x, point.y - y);
        if (dist < minDist) {
          minDist = dist;
          best = point;
        }
      }
      return best;
    }

    function handleScatterMove(event) {
      const rect = dom.scatter.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const point = findPointAt(mx, my);
      const tooltip = dom.scatterTooltip;

      if (point) {
        if (state.scatter.hoverId !== point.rowId) {
          state.scatter.hoverId = point.rowId;
          scheduleScatterRender();
        }
        tooltip.textContent = `${point.label} ‚Äî double-tap or press the button to add neighbours`;
        tooltip.style.display = "block";
        const width = tooltip.offsetWidth || 240;
        const offsetX = Math.min(event.clientX + 14, window.innerWidth - width - 12);
        const offsetY = Math.max(event.clientY - 24, 12);
        tooltip.style.left = `${offsetX}px`;
        tooltip.style.top = `${offsetY}px`;
      } else {
        if (state.scatter.hoverId !== null) {
          state.scatter.hoverId = null;
          scheduleScatterRender();
        }
        tooltip.style.display = "none";
      }
    }

    const DOUBLE_TAP_MS = 350;

    function handleScatterClick(event) {
      const rect = dom.scatter.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const point = findPointAt(mx, my);
      if (!point) return;
      const now = Date.now();
      const isDoubleTap = state.scatter.lastTapId === point.rowId && (now - state.scatter.lastTapTime) <= DOUBLE_TAP_MS;
      state.scatter.lastTapId = point.rowId;
      state.scatter.lastTapTime = now;
      setScatterFocus(point.rowId);
      if (isDoubleTap) {
        state.scatter.skipNextDblClick = true;
        selectNeighbors(point.rowId);
        return;
      }
      toggleSelection(point.rowId);
    }

    function handleScatterDblClick(event) {
      if (state.scatter.skipNextDblClick) {
        state.scatter.skipNextDblClick = false;
        return;
      }
      const rect = dom.scatter.getBoundingClientRect();
      const mx = event.clientX - rect.left;
      const my = event.clientY - rect.top;
      const point = findPointAt(mx, my);
      if (!point) return;
      setScatterFocus(point.rowId);
      selectNeighbors(point.rowId);
    }

    async function loadCsv(path) {
      return new Promise((resolve, reject) => {
        if (!window.Papa) return reject(new Error("Papa Parse failed to load."));
        Papa.parse(path, {
          download: true,
          header: true,
          skipEmptyLines: true,
          dynamicTyping: false,
          complete: (res) => resolve(res.data),
          error: (err) => reject(err)
        });
      });
    }

    function normalizeHeaders(obj) {
      const map = {};
      Object.keys(obj).forEach(k => {
        const nk = k.replace(/\s+/g, "_");
        map[nk] = obj[k];
      });
      return map;
    }

    function bootstrapFilters() {
      numericFields.forEach(field => {
        const values = state.rows.map(row => row._values[field]).filter(val => val !== null);
        const absoluteMin = values.length ? Math.floor(Math.min(...values)) : 0;
        const absoluteMax = values.length ? Math.ceil(Math.max(...values)) : 100;
        state.filters[field] = {
          absoluteMin,
          absoluteMax,
          min: absoluteMin,
          max: absoluteMax
        };
      });
      buildFilters();
      attachFilterListeners();
    }

    async function createPlaylistAndAddTracks() {
      try {
        const playlistName = dom.playlistName.value.trim() || "PKCE Demo Playlist";
        const selectedUris = Array.from(state.selected)
          .map(id => state.rows[id]?.Spotify_URI)
          .filter(uri => uri && uri.length > 0);
        if (!selectedUris.length) {
          log("No tracks selected.", "err");
          return;
        }
        log("Fetching your profile (/me)‚Ä¶");
        const me = await apiFetch("/me");
        if (!me.ok) throw new Error(JSON.stringify(me.json));
        const userId = me.json.id;
        log(`Hello ${me.json.display_name || userId}!`, "ok");
        log(`Creating playlist "${playlistName}"‚Ä¶`);
        const newPl = await apiFetch(`/users/${encodeURIComponent(userId)}/playlists`, {
          method: "POST",
          body: JSON.stringify({
            name: playlistName,
            description: "Created by Spotify CSV Browser",
            public: false
          })
        });
        if (!newPl.ok) throw new Error(JSON.stringify(newPl.json));
        const playlistId = newPl.json.id;
        log(`Created: ${newPl.json.name}`, "ok");
        log(`Adding ${selectedUris.length} track(s) to playlist‚Ä¶`);
        const chunkSize = 100;
        let addedCount = 0;
        for (let i = 0; i < selectedUris.length; i += chunkSize) {
          const batch = selectedUris.slice(i, i + chunkSize);
          const addResp = await apiFetch(`/playlists/${playlistId}/tracks`, {
            method: "POST",
            body: JSON.stringify({ uris: batch })
          });
          if (!addResp.ok) throw new Error(JSON.stringify(addResp.json));
          addedCount += batch.length;
          log(`Added ${addedCount}/${selectedUris.length} track(s)‚Ä¶`, "ok");
        }
        log(`Added ${selectedUris.length} track(s) successfully!`, "ok");
      } catch (err) {
        log(`Error: ${err.message}`, "err");
        console.error(err);
      }
    }

    function resetFilters() {
      numericFields.forEach(field => {
        const range = state.filters[field];
        if (!range) return;
        range.min = range.absoluteMin;
        range.max = range.absoluteMax;
        updateFilterLabels(field);
      });
      scheduleViewRefresh();
    }

    function setupEvents() {
      dom.loginBtn.addEventListener("click", beginLogin);
      dom.createPlaylistBtn.addEventListener("click", createPlaylistAndAddTracks);

      dom.loadCsvBtn.addEventListener("click", async () => {
        const path = dom.csvPath.value.trim() || "songs.csv";
        try {
          log(`Loading ${path}‚Ä¶`);
          const data = await loadCsv(path);
          state.rows = data.map((row, idx) => {
            const normalized = normalizeHeaders(row);
            normalized._idx = idx;
            normalized._values = {};
            numericFields.forEach(field => {
              normalized._values[field] = getNumericValue(normalized[field]);
            });
            normalized._haystack = [normalized.Title, normalized.Artist, normalized.Release, normalized.Spotify_Artists]
              .filter(Boolean)
              .join(" ")
              .toLowerCase();
            return normalized;
          });
          state.selected.clear();
          state.search = dom.filterInput.value.trim().toLowerCase();
          state.scatter.dirty = true;
          bootstrapFilters();
          refreshView();
          log(`Loaded ${state.rows.length} rows.`, "ok");
        } catch (err) {
          console.error(err);
          log(`Failed to load CSV: ${err.message}`, "err");
        }
      });

      dom.filterInput.addEventListener("input", debounce(event => {
        state.search = event.target.value.trim().toLowerCase();
        scheduleViewRefresh();
      }, 180));

      dom.selectAll.addEventListener("change", event => {
        if (event.target.checked) {
          state.view.forEach(row => state.selected.add(row._idx));
        } else {
          state.view.forEach(row => state.selected.delete(row._idx));
        }
        updateSelectionCheckboxes();
        updateSelectedCount();
      });

      dom.deselectAllBtn.addEventListener("click", () => {
        state.selected.clear();
        updateSelectionCheckboxes();
        updateSelectedCount();
      });

      dom.knnK.addEventListener("change", event => {
        const value = Number(event.target.value);
        if (Number.isFinite(value) && value >= 1 && value <= 50) {
          state.knn.k = value;
          log(`KNN k set to ${value}`, "ok");
        } else {
          event.target.value = state.knn.k;
        }
      });

      dom.knnDimContainer.addEventListener("click", event => {
        const button = event.target.closest(".knn-dim-btn");
        if (!button) return;
        const field = button.dataset.dim;
        const nextState = !state.knn.dimensions[field];
        if (!nextState && Object.values(state.knn.dimensions).filter(Boolean).length === 1) {
          log("At least one dimension must remain enabled.", "err");
          return;
        }
        state.knn.dimensions[field] = nextState;
        button.classList.toggle("active", nextState);
        button.setAttribute("aria-pressed", nextState ? "true" : "false");
        log(`${field} ${nextState ? "enabled" : "disabled"}.`, "ok");
        scheduleScatterRender(true);
      });

      dom.tableHead.addEventListener("click", event => {
        const th = event.target.closest("th[data-key]");
        if (!th) return;
        const key = th.dataset.key;
        if (!key) return;
        if (state.sort.key === key) {
          state.sort.dir = state.sort.dir === "asc" ? "desc" : "asc";
        } else {
          state.sort.key = key;
          state.sort.dir = "asc";
        }
        refreshView();
      });

      dom.csvBody.addEventListener("change", event => {
        if (!event.target.classList.contains("rowCheckbox")) return;
        const rowId = Number(event.target.dataset.rowId);
        if (event.target.checked) state.selected.add(rowId);
        else state.selected.delete(rowId);
        updateSelectAllState();
        updateSelectedCount();
      });

      dom.csvBody.addEventListener("click", event => {
        const button = event.target.closest(".knn-btn");
        if (button) {
          const row = button.closest("tr[data-row-id]");
          if (row) selectNeighbors(Number(row.dataset.rowId));
          return;
        }
        if (event.target.closest("a")) return;
        if (event.target.classList.contains("rowCheckbox")) return;
        const row = event.target.closest("tr[data-row-id]");
        if (!row) return;
        toggleSelection(Number(row.dataset.rowId));
      });

      dom.csvBody.addEventListener("dblclick", event => {
        if (event.target.closest("a")) return;
        const row = event.target.closest("tr[data-row-id]");
        if (!row) return;
        selectNeighbors(Number(row.dataset.rowId));
      });

      if (dom.scatter) {
        dom.scatter.addEventListener("click", handleScatterClick);
        dom.scatter.addEventListener("dblclick", handleScatterDblClick);
        dom.scatter.addEventListener("mousemove", handleScatterMove);
        dom.scatter.addEventListener("mouseleave", () => {
          state.scatter.hoverId = null;
          dom.scatterTooltip.style.display = "none";
          scheduleScatterRender();
        });
      }

      if (dom.scatterKnnBtn) {
        dom.scatterKnnBtn.addEventListener("click", () => {
          const rowId = state.scatter.lastActivatedId;
          if (rowId === null) return;
          selectNeighbors(rowId);
        });
      }

      dom.resetFiltersBtn.addEventListener("click", resetFilters);
      window.addEventListener("resize", () => scheduleScatterRender(true));
      updateScatterKnnUi();
    }

    async function initAuth() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get("code");
      const error = params.get("error");
      if (error) {
        log(`Auth error: ${error}`, "err");
      }

      if (code) {
        try {
          log("Exchanging authorization code for access token‚Ä¶");
          await exchangeCodeForToken(code);
          window.history.replaceState({}, document.title, window.location.pathname);
          setAuthStatus("‚úì Logged in");
          dom.createPlaylistBtn.disabled = state.selected.size === 0;
          log("Logged in successfully!", "ok");
        } catch (err) {
          log(`Token exchange failed: ${err.message}`, "err");
        }
      } else if (localStorage.getItem("access_token")) {
        setAuthStatus("‚úì Logged in");
        dom.createPlaylistBtn.disabled = state.selected.size === 0;
        log("Token present.", "ok");
      } else {
        setAuthStatus("Not logged in");
        log("CSV features work without login. Log in to create playlists.", "");
      }
    }

    buildKnnControls();
    attachFilterListeners();
    setupEvents();
    initAuth();
    updateSelectedCount();
    scheduleScatterRender(true);
  </script>
</body>
</html>
