<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Spotify CSV Browser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pad: 12px; --radius: 12px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 32px; }
    h1, h2 { margin: 0 0 12px; }
    section { margin: 28px 0; }
    button, input { padding: 10px 14px; font-size: 15px; }
    #log { white-space: pre-wrap; border: 1px solid #ddd; padding: var(--pad); border-radius: var(--radius); margin-top: 12px; font-size: 14px; max-height: 200px; overflow-y: auto; }
    .ok { color: #087443; } .err { color: #a40000; }

    .card { border: 1px solid #e5e5e5; border-radius: var(--radius); padding: var(--pad); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .muted { color: #666; font-size: 13px; }

    .table-wrap { border: 1px solid #e5e5e5; border-radius: var(--radius); overflow: hidden; }
    table { border-collapse: collapse; width: 100%; font-size: 14px; }
    thead th { background: #fafafa; font-weight: 600; text-align: left; border-bottom: 1px solid #eee; padding: 10px; cursor: pointer; user-select: none; }
    tbody td { border-bottom: 1px solid #f3f3f3; padding: 8px 10px; vertical-align: top; }
    tbody tr:hover { background: #fffdf7; }
    .sticky { position: sticky; top: 0; z-index: 1; }
    .scroll { max-height: 520px; overflow: auto; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .right { text-align: right; }
    .link { text-decoration: none; }
    .th-sort::after { content: attr(data-sort); margin-left: 6px; font-size: 11px; color: #999; }
    .row-space { justify-content: space-between; }
    .filter-item { display: flex; flex-direction: column; gap: 8px; }
    .filter-label { font-weight: 600; font-size: 14px; }
    .filter-stats { font-size: 12px; color: #666; }
    .histogram { width: 100%; height: 40px; display: flex; align-items: flex-end; gap: 1px; margin: 6px 0; background: #fafafa; border-radius: 6px; padding: 2px; box-sizing: border-box; }
    .histogram-bar { flex: 1; background: #0084ff; border-radius: 1px; min-height: 1px; transition: background 0.2s; }
    .histogram-bar:hover { background: #0066cc; }
    .range-slider-container { display: flex; flex-direction: column; gap: 6px; }
    .range-slider { width: 100%; height: 6px; cursor: pointer; }
    .range-values { display: flex; justify-content: space-between; font-size: 11px; color: #666; }
    input[type="range"] { width: 100%; cursor: pointer; }
    .scatter-container { margin-top: 20px; display: flex; flex-direction: column; align-items: center; }
    .scatter-canvas { border: 1px solid #e5e5e5; border-radius: var(--radius); cursor: crosshair; width: 100%; height: auto; max-width: 800px; aspect-ratio: 1; }
    .scatter-label { font-size: 12px; color: #666; margin-top: 8px; }
    .scatter-tooltip { position: fixed; background: #333; color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; white-space: nowrap; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" defer></script>
</head>
  <h1>Spotify CSV Browser</h1>
  <p class="muted">Load, filter, sort, and browse track data from CSV files.</p>

  <section class="card">
    <h2>Numeric Filters</h2>
    <div id="filtersContainer" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 32px;">
      <!-- Sliders will be inserted here -->
    </div>
  </section>

  <section class="card">
    <h2>KNN Settings</h2>
    <div class="row" style="gap: 24px; flex-wrap: wrap;">
      <div class="filter-item">
        <label class="filter-label" for="knnK">Number of neighbors (k):</label>
        <input id="knnK" type="number" min="1" max="50" value="5" style="width: 80px;" />
      </div>
      <div class="filter-item">
        <span class="filter-label">Dimensions:</span>
        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
          <label style="display: flex; gap: 6px; align-items: center; cursor: pointer;">
            <input type="checkbox" id="knnDim-BPM" checked />
            <span style="font-size: 14px;">BPM</span>
          </label>
          <label style="display: flex; gap: 6px; align-items: center; cursor: pointer;">
            <input type="checkbox" id="knnDim-Energy" checked />
            <span style="font-size: 14px;">Energy</span>
          </label>
          <label style="display: flex; gap: 6px; align-items: center; cursor: pointer;">
            <input type="checkbox" id="knnDim-Dance" checked />
            <span style="font-size: 14px;">Dance</span>
          </label>
          <label style="display: flex; gap: 6px; align-items: center; cursor: pointer;">
            <input type="checkbox" id="knnDim-Valence" checked />
            <span style="font-size: 14px;">Valence</span>
          </label>
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>CSV Browser</h2>
    <div class="row" style="justify-content:space-between;">
      <div class="row">
        <label for="csvPath" class="muted">CSV path:</label>
        <input id="csvPath" type="text" value="songs.csv" class="mono" size="24" />
        <button id="loadCsvBtn">Load CSV</button>
      </div>
      <div class="row">
        <input id="filterInput" type="search" placeholder="Filter: title / artist / album‚Ä¶" />
        <button id="deselectAllBtn">Deselect All</button>
      </div>
    </div>
    <div style="height:10px"></div>
    <div class="table-wrap">
      <div class="scroll">
        <table id="csvTable">
          <thead>
            <tr>
              <th class="sticky"><input type="checkbox" id="selectAll" /></th>
              <th data-key="Title" class="sticky th-sort" data-sort="">Title</th>
              <th data-key="Artist" class="sticky th-sort" data-sort="">Artist</th>
              <th data-key="Release" class="sticky th-sort" data-sort="">Release</th>
              <th data-key="BPM" class="sticky right th-sort" data-sort="">BPM</th>
              <th data-key="Energy" class="sticky right th-sort" data-sort="">Energy</th>
              <th data-key="Dance" class="sticky right th-sort" data-sort="">Dance</th>
              <th data-key="Valence" class="sticky right th-sort" data-sort="">Valence</th>
              <th data-key="Spotify_URL" class="sticky">Open</th>
            </tr>
          </thead>
          <tbody id="csvBody">
          </tbody>
        </table>
      </div>
    </div>
    <div class="muted" style="margin-top:8px">Tip: click headers to sort; use the filter to search by title, artist, or album. Click any row to select/deselect.</div>
    <div class="scatter-container">
      <canvas id="scatterPlot" class="scatter-canvas"></canvas>
      <div id="scatterTooltip" class="scatter-tooltip"></div>
      <div class="scatter-label">Energy (x-axis) vs. Valence (y-axis) ‚Ä¢ Click points to select tracks</div>
    </div>
  </section>

  <section class="card">
    <h2>Playlist & Sync</h2>
    <div class="row row-space">
      <div class="row">
        <button id="loginBtn">Log in with Spotify</button>
        <span id="authStatus" class="muted"></span>
        <span style="margin: 0 8px; color: #ddd;">|</span>
        <span id="selectedCount" class="muted"></span>
      </div>
      <div class="row">
        <input id="playlistName" type="text" placeholder="Playlist name" value="PKCE Demo Playlist" />
        <button id="createPlaylistBtn" disabled>Create & Add Selected Tracks</button>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Log</h2>
    <div id="log" aria-live="polite" style="display:none;"></div>
  </section>

<script>
const CLIENT_ID = "2a1b848324a04242b06d3a1d0e5c16d9";
const SCOPES = "playlist-modify-public playlist-modify-private user-read-private";
const REDIRECT_URI = window.location.origin + window.location.pathname;

const logEl = document.getElementById("log");
const authStatusEl = document.getElementById("authStatus");
function log(msg, cls="") {
  logEl.style.display = "block";
  const p = document.createElement("div");
  if (cls) p.className = cls;
  p.textContent = msg;
  logEl.appendChild(p);
  logEl.scrollTop = logEl.scrollHeight;
}

function setAuthStatus(msg) {
  authStatusEl.textContent = msg;
}

function generateRandomString(length) {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const values = crypto.getRandomValues(new Uint8Array(length));
  return values.reduce((acc, x) => acc + possible[x % possible.length], "");
}
async function sha256(plain) {
  const encoder = new TextEncoder();
  const data = encoder.encode(plain);
  return crypto.subtle.digest('SHA-256', data);
}
function base64urlencode(bytes) {
  const str = String.fromCharCode(...new Uint8Array(bytes));
  return btoa(str).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
async function beginLogin() {
  const codeVerifier = generateRandomString(64);
  localStorage.setItem("code_verifier", codeVerifier);
  const codeChallenge = base64urlencode(await sha256(codeVerifier));
  const authUrl = new URL("https://accounts.spotify.com/authorize");
  authUrl.search = new URLSearchParams({
    response_type: "code",
    client_id: CLIENT_ID,
    scope: SCOPES,
    code_challenge_method: "S256",
    code_challenge: codeChallenge,
    redirect_uri: REDIRECT_URI,
    state: generateRandomString(16)
  }).toString();
  window.location.href = authUrl.toString();
}
async function exchangeCodeForToken(code) {
  const codeVerifier = localStorage.getItem("code_verifier");
  if (!codeVerifier) throw new Error("Missing code_verifier.");
  const body = new URLSearchParams({
    client_id: CLIENT_ID,
    grant_type: "authorization_code",
    code,
    redirect_uri: REDIRECT_URI,
    code_verifier: codeVerifier
  });
  const resp = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });
  const data = await resp.json();
  if (!resp.ok) throw new Error((data && data.error_description) || resp.statusText);
  localStorage.setItem("access_token", data.access_token);
  localStorage.setItem("refresh_token", data.refresh_token || "");
  return data.access_token;
}
async function apiFetch(path, options = {}) {
  const token = localStorage.getItem("access_token");
  if (!token) throw new Error("No access token.");
  const resp = await fetch(`https://api.spotify.com/v1${path}`, {
    ...options,
    headers: {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json",
      ...(options.headers || {})
    }
  });
  if (resp.status === 401) throw new Error("Unauthorized (token expired?)");
  const text = await resp.text();
  try { return { ok: resp.ok, status: resp.status, json: JSON.parse(text) }; }
  catch { return { ok: resp.ok, status: resp.status, json: text }; }
}

const $ = (s) => document.querySelector(s);
const csvBody = $("#csvBody");
const filterInput = $("#filterInput");
let csvRows = [];
let viewRows = [];
let sortState = { key: "Title", dir: "asc" };
let pointMap = {}; // Maps point indices to row indices
let hoveredPointIdx = null;

const filterState = {
  BPM: { min: 0, max: 300 },
  Energy: { min: 0, max: 100 },
  Dance: { min: 0, max: 100 },
  Valence: { min: 0, max: 100 }
};

const knnSettings = {
  k: 5,
  dimensions: {
    BPM: true,
    Energy: true,
    Dance: true,
    Valence: true
  }
};

// Hardcoded field ranges for normalization
const fieldRanges = {
  BPM: { min: 10, max: 200 },
  Energy: { min: 0, max: 100 },
  Dance: { min: 0, max: 100 },
  Valence: { min: 0, max: 100 }
};

function getNumericValue(val) {
  if (val === null || val === undefined || val === "") return null;
  const n = Number(String(val).replace(/[^0-9.\-]/g, ""));
  return Number.isFinite(n) ? n : null;
}

// Normalize value to 0-1 using hardcoded ranges
function normalizeValue(val, field) {
  if (val === null || !fieldRanges[field]) return null;
  // Only normalize if the field dimension is enabled
  if (!knnSettings.dimensions[field]) return null;
  const { min, max } = fieldRanges[field];
  const span = max - min || 1;
  return (val - min) / span;
}

// Calculate Euclidean distance in enabled dimensions
function calculateDistance(row1, row2) {
  let sumSquares = 0;
  let activeCount = 0;
  
  Object.keys(knnSettings.dimensions).forEach(field => {
    if (!knnSettings.dimensions[field]) return;
    
    const val1 = getNumericValue(row1[field]);
    const val2 = getNumericValue(row2[field]);
    
    if (val1 !== null && val2 !== null) {
      const norm1 = normalizeValue(val1, field);
      const norm2 = normalizeValue(val2, field);
      
      if (norm1 !== null && norm2 !== null) {
        const diff = norm1 - norm2;
        sumSquares += diff * diff;
        activeCount++;
      }
    }
  });
  
  return activeCount === 0 ? Infinity : Math.sqrt(sumSquares);
}

// Find k nearest neighbors for a row in csvRows, optionally excluding specific indices
function findNearestNeighbors(csvRowIdx, excludeSet = null) {
  const k = knnSettings.k;
  const targetRow = csvRows[csvRowIdx];
  
  const distances = csvRows.map((row, idx) => ({
    idx,
    distance: idx === csvRowIdx ? Infinity : calculateDistance(targetRow, row)
  }));
  
  // Filter out excluded indices
  const filtered = distances.filter(d => !excludeSet || !excludeSet.has(d.idx));
  filtered.sort((a, b) => a.distance - b.distance);
  return filtered.slice(0, k).map(d => d.idx);
}

// Select neighbors in the table: finds them in viewRows and checks them
function selectNeighbors(csvRowIdx) {
  // Build set of already selected csvRow indices
  const alreadySelected = new Set();
  alreadySelected.add(csvRowIdx); // Always exclude the target song itself
  
  document.querySelectorAll(".rowCheckbox:checked").forEach(cb => {
    const idx = parseInt(cb.dataset.idx);
    const row = viewRows[idx];
    if (row) {
      alreadySelected.add(csvRows.indexOf(row));
    }
  });
  
  // Find k neighbors excluding already selected
  const neighborCsvIndices = findNearestNeighbors(csvRowIdx, alreadySelected);
  
  // Check target song if not already checked
  const targetViewIdx = viewRows.findIndex(r => csvRows.indexOf(r) === csvRowIdx);
  if (targetViewIdx !== -1) {
    const checkbox = document.querySelector(`.rowCheckbox[data-idx="${targetViewIdx}"]`);
    if (checkbox && !checkbox.checked) {
      checkbox.click();
    }
  }
  
  // Check the neighbors (they should all be unselected at this point)
  let addedCount = 0;
  for (const nCsvIdx of neighborCsvIndices) {
    const nViewIdx = viewRows.findIndex(r => csvRows.indexOf(r) === nCsvIdx);
    if (nViewIdx !== -1) {
      const checkbox = document.querySelector(`.rowCheckbox[data-idx="${nViewIdx}"]`);
      if (checkbox && !checkbox.checked) {
        checkbox.click();
        addedCount++;
      }
    }
  }
  
  updateSelectedCount();
  updateScatterPlot();
  log(`Added ${addedCount} new neighbors to selection`, "ok");
}

function buildHistogram(field, binCount = 10) {
  const values = csvRows
    .map(r => getNumericValue(r[field]))
    .filter(v => v !== null);
  
  if (values.length === 0) return { bins: [], min: 0, max: 0 };

  const min = Math.min(...values);
  const max = Math.max(...values);
  const bins = Array(binCount).fill(0);
  const range = max - min || 1;

  values.forEach(v => {
    const binIdx = Math.min(
      Math.floor(((v - min) / range) * binCount),
      binCount - 1
    );
    bins[binIdx]++;
  });

  return { bins, min, max };
}

function renderFilters() {
  const container = document.getElementById("filtersContainer");
  container.innerHTML = "";

  const fields = ["BPM", "Energy", "Dance", "Valence"];
  fields.forEach(field => {
    const { bins, min, max } = buildHistogram(field, 20);
    const state = filterState[field];
    const maxBin = Math.max(...bins, 1);

    const item = document.createElement("div");
    item.className = "filter-item";
    item.innerHTML = `
      <div class="filter-label">${field}</div>
      <div class="histogram">
        ${bins.map(count => 
          `<div class="histogram-bar" style="height: ${(count / maxBin) * 100}%;" title="${count}"></div>`
        ).join("")}
      </div>
      <div class="range-slider-container">
        <input type="range" class="range-slider filter-min-slider" min="${Math.floor(min)}" max="${Math.ceil(max)}" value="${state.min}" />
        <input type="range" class="range-slider filter-max-slider" min="${Math.floor(min)}" max="${Math.ceil(max)}" value="${state.max}" />
      </div>
      <div class="range-values">
        <span class="min-display">${state.min}</span>
        <span class="max-display">${state.max}</span>
      </div>
      <div class="filter-stats">Range: ${Math.floor(min)} to ${Math.ceil(max)}</div>
    `;

    const minSlider = item.querySelector(".filter-min-slider");
    const maxSlider = item.querySelector(".filter-max-slider");
    const minDisplay = item.querySelector(".min-display");
    const maxDisplay = item.querySelector(".max-display");

    minSlider.addEventListener("input", () => {
      const newMin = Math.min(Number(minSlider.value), state.max);
      state.min = newMin;
      minSlider.value = newMin;
      minDisplay.textContent = newMin;
      renderTable();
    });

    maxSlider.addEventListener("input", () => {
      const newMax = Math.max(Number(maxSlider.value), state.min);
      state.max = newMax;
      maxSlider.value = newMax;
      maxDisplay.textContent = newMax;
      renderTable();
    });

    container.appendChild(item);
  });
}

function toNumberMaybe(v) {
  if (v === null || v === undefined) return null;
  const n = Number(String(v).replace(/[^0-9.\-]/g, ""));
  return Number.isFinite(n) ? n : null;
}
function escapeHTML(s) {
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}
function updateSelectedCount() {
  const checked = document.querySelectorAll(".rowCheckbox:checked").length;
  document.getElementById("selectedCount").textContent = `${checked} track${checked !== 1 ? "s" : ""} selected`;
}
function renderScatterPlot() {
  const canvas = document.getElementById("scatterPlot");
  const size = Math.min(800, canvas.offsetWidth);
  canvas.width = size;
  canvas.height = size;
  
  const ctx = canvas.getContext("2d");
  const padding = 40;
  const plotSize = size - 2 * padding;

  // Clear canvas
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, size, size);

  // Draw axes
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, size - padding);
  ctx.lineTo(size - padding, size - padding);
  ctx.stroke();

  // Draw axis labels
  ctx.fillStyle = "#666";
  ctx.font = "12px system-ui";
  ctx.textAlign = "center";
  ctx.fillText("Energy", size / 2, size - 10);
  ctx.textAlign = "right";
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("Valence", -size / 2, 15);
  ctx.rotate(Math.PI / 2);

  // Draw grid lines and tick labels
  ctx.strokeStyle = "#f0f0f0";
  ctx.lineWidth = 1;
  ctx.fillStyle = "#999";
  ctx.font = "11px system-ui";
  ctx.textAlign = "center";
  for (let i = 0; i <= 100; i += 20) {
    const x = padding + (i / 100) * plotSize;
    ctx.beginPath();
    ctx.moveTo(x, size - padding);
    ctx.lineTo(x, padding);
    ctx.stroke();
    ctx.fillText(i, x, size - padding + 15);
  }

  ctx.textAlign = "right";
  for (let i = 0; i <= 100; i += 20) {
    const y = size - padding - (i / 100) * plotSize;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(size - padding, y);
    ctx.stroke();
    ctx.fillText(i, padding - 10, y + 4);
  }

  // Plot points
  pointMap = {};
  let pointIndex = 0;
  viewRows.forEach((row, idx) => {
    const energy = getNumericValue(row.Energy);
    const valence = getNumericValue(row.Valence);

    if (energy !== null && valence !== null) {
      const x = padding + (energy / 100) * plotSize;
      const y = size - padding - (valence / 100) * plotSize;

      const isSelected = document.querySelector(`.rowCheckbox[data-idx="${idx}"]`)?.checked || false;
      const isHovered = hoveredPointIdx === pointIndex;
      const pointRadius = isSelected || isHovered ? 6 : 4;

      ctx.fillStyle = isSelected ? "#0084ff" : (isHovered ? "#ff6b35" : "#ccc");
      ctx.beginPath();
      ctx.arc(x, y, pointRadius, 0, Math.PI * 2);
      ctx.fill();

      if (isSelected || isHovered) {
        ctx.strokeStyle = isSelected ? "#0066cc" : "#ff4500";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, pointRadius + 2, 0, Math.PI * 2);
        ctx.stroke();
      }

      const csvRowIdx = csvRows.indexOf(row);
      pointMap[pointIndex] = { idx, x, y, radius: pointRadius + 2, title: row.Title, artist: row.Artist, csvRowIdx };
      pointIndex++;
    }
  });
}

function getPointAtCoords(canvas, mx, my) {
  Object.entries(pointMap).forEach(([idx, point]) => {
    const dist = Math.sqrt(Math.pow(mx - point.x, 2) + Math.pow(my - point.y, 2));
    if (dist <= point.radius + 4) {
      return parseInt(idx);
    }
  });
  return null;
}

function updateScatterPlot() {
  renderScatterPlot();
}

function renderTable() {
  const q = filterInput.value.trim().toLowerCase();
  if (q) {
    viewRows = csvRows.filter(r => {
      const hay = [r.Title, r.Artist, r.Release, r.Spotify_Artists].filter(Boolean).join(" ").toLowerCase();
      return hay.includes(q);
    });
  } else {
    viewRows = csvRows.slice();
  }

  // Apply numeric range filters
  viewRows = viewRows.filter(r => {
    for (const field of ["BPM", "Energy", "Dance", "Valence"]) {
      const val = getNumericValue(r[field]);
      if (val !== null) {
        const state = filterState[field];
        if (val < state.min || val > state.max) return false;
      }
    }
    return true;
  });

  const { key, dir } = sortState;
  viewRows.sort((a,b) => {
    const av = a[key], bv = b[key];
    const an = toNumberMaybe(av), bn = toNumberMaybe(bv);
    let cmp;
    if (an !== null && bn !== null) cmp = an - bn;
    else cmp = String(av ?? "").localeCompare(String(bv ?? ""), undefined, { numeric: true, sensitivity: "base" });
    return dir === "asc" ? cmp : -cmp;
  });

  const rowsHtml = viewRows.map((r, idx) => {
    const spotifyUrl = r.Spotify_URL || (r.Spotify_Track_ID ? `https://open.spotify.com/track/${r.Spotify_Track_ID}` : "");
    const csvRowIdx = csvRows.indexOf(r);
    return `<tr data-uri="${escapeHTML(r.Spotify_URI || "")}" data-csv-idx="${csvRowIdx}">
      <td><input type="checkbox" class="rowCheckbox" data-idx="${idx}" /></td>
      <td><button class="knn-btn" title="Find similar tracks">üîç</button> ${escapeHTML(r.Title ?? "")}</td>
      <td>${escapeHTML(r.Artist ?? r.Spotify_Artists ?? "")}</td>
      <td>${escapeHTML(r.Release ?? r.Spotify_Release_Date ?? "")}</td>
      <td class="right">${escapeHTML(r.BPM ?? "")}</td>
      <td class="right">${escapeHTML(r.Energy ?? "")}</td>
      <td class="right">${escapeHTML(r.Dance ?? "")}</td>
      <td class="right">${escapeHTML(r.Valence ?? "")}</td>
      <td>${spotifyUrl ? `<a class="link" href="${escapeHTML(spotifyUrl)}" target="_blank" rel="noopener">Open</a>` : ""}</td>
    </tr>`;
  }).join("");
  csvBody.innerHTML = rowsHtml || `<tr><td colspan="9" class="muted">No rows.</td></tr>`;

  document.querySelectorAll("thead th.th-sort").forEach(th => {
    const k = th.dataset.key;
    th.setAttribute("data-sort", k === key ? (dir === "asc" ? "‚ñ≤" : "‚ñº") : "");
  });

  document.querySelectorAll(".rowCheckbox").forEach(cb => {
    cb.addEventListener("change", () => {
      updateSelectedCount();
      updateScatterPlot();
    });
  });

  document.querySelectorAll(".knn-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const csvRowIdx = parseInt(btn.closest("tr").dataset.csvIdx);
      selectNeighbors(csvRowIdx);
    });
  });

  document.querySelectorAll("tbody tr").forEach(tr => {
    tr.addEventListener("click", (e) => {
      if (e.target.tagName === "A" || e.target.tagName === "BUTTON") return;
      if (e.target.type === "checkbox") return;
      const checkbox = tr.querySelector(".rowCheckbox");
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        updateSelectedCount();
        updateScatterPlot();
      }
    });
    
    tr.addEventListener("dblclick", (e) => {
      if (e.target.tagName === "A") return;
      const csvRowIdx = parseInt(tr.dataset.csvIdx);
      selectNeighbors(csvRowIdx);
    });
  });

  updateScatterPlot();
}

async function loadCsv(path) {
  return new Promise((resolve, reject) => {
    if (!window.Papa) return reject(new Error("Papa Parse failed to load."));
    Papa.parse(path, {
      download: true,
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      complete: (res) => resolve(res.data),
      error: (err) => reject(err),
    });
  });
}

function normalizeHeaders(obj) {
  const map = {};
  Object.keys(obj).forEach(k => {
    const nk = k.replace(/\s+/g, "_");
    map[nk] = obj[k];
  });
  return map;
}

async function createPlaylistAndAddTracks() {
  try {
    const playlistName = document.getElementById("playlistName").value.trim() || "PKCE Demo Playlist";
    const selectedCheckboxes = document.querySelectorAll(".rowCheckbox:checked");
    const selectedUris = Array.from(selectedCheckboxes).map(cb => {
      const tr = cb.closest("tr");
      return tr.dataset.uri;
    }).filter(uri => uri && uri.length > 0);

    if (selectedUris.length === 0) {
      log("No tracks selected.", "err");
      return;
    }

    log("Fetching your profile (/me)‚Ä¶");
    const me = await apiFetch("/me");
    if (!me.ok) throw new Error(JSON.stringify(me.json));
    const userId = me.json.id;
    log(`Hello ${me.json.display_name || userId}!`, "ok");

    log(`Creating playlist "${playlistName}"‚Ä¶`);
    const newPl = await apiFetch(`/users/${encodeURIComponent(userId)}/playlists`, {
      method: "POST",
      body: JSON.stringify({
        name: playlistName,
        description: "Created by Spotify CSV Browser",
        public: false
      })
    });
    if (!newPl.ok) throw new Error(JSON.stringify(newPl.json));
    const playlistId = newPl.json.id;
    log(`Created: ${newPl.json.name}`, "ok");

    log(`Adding ${selectedUris.length} track(s) to playlist‚Ä¶`);
    const addResp = await apiFetch(`/playlists/${playlistId}/tracks`, {
      method: "POST",
      body: JSON.stringify({ uris: selectedUris })
    });
    if (!addResp.ok) throw new Error(JSON.stringify(addResp.json));
    log(`Added ${selectedUris.length} track(s) successfully!`, "ok");
  } catch (e) {
    log(`Error: ${e.message}`, "err");
    console.error(e);
  }
}

document.getElementById("loginBtn").addEventListener("click", beginLogin);
document.getElementById("createPlaylistBtn").addEventListener("click", createPlaylistAndAddTracks);

document.getElementById("loadCsvBtn").addEventListener("click", async () => {
  const path = document.getElementById("csvPath").value.trim() || "songs.csv";
  try {
    const data = await loadCsv(path);
    csvRows = data.map(normalizeHeaders);
    renderFilters();
    renderTable();
    // Do NOT auto-select all checkboxes
    updateSelectedCount();
    updateScatterPlot();
    log(`Loaded ${csvRows.length} rows.`, "ok");
  } catch (e) {
    console.error(e);
    log(`Failed to load CSV: ${e.message}`, "err");
  }
});

filterInput.addEventListener("input", renderTable);

document.querySelectorAll("thead th.th-sort").forEach(th => {
  th.addEventListener("click", () => {
    const key = th.dataset.key;
    if (sortState.key === key) {
      sortState.dir = sortState.dir === "asc" ? "desc" : "asc";
    } else {
      sortState.key = key;
      sortState.dir = "asc";
    }
    renderTable();
  });
});

document.getElementById("selectAll").addEventListener("change", (e) => {
  document.querySelectorAll(".rowCheckbox").forEach(cb => cb.checked = e.target.checked);
  updateSelectedCount();
  updateScatterPlot();
});

document.getElementById("deselectAllBtn").addEventListener("click", () => {
  document.querySelectorAll(".rowCheckbox").forEach(cb => cb.checked = false);
  document.getElementById("selectAll").checked = false;
  updateSelectedCount();
  updateScatterPlot();
});

document.getElementById("scatterPlot").addEventListener("click", (e) => {
  const canvas = document.getElementById("scatterPlot");
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let closestIdx = null;
  let closestDist = Infinity;
  
  Object.entries(pointMap).forEach(([_, point]) => {
    const dist = Math.sqrt(Math.pow(mx - point.x, 2) + Math.pow(my - point.y, 2));
    if (dist < closestDist) {
      closestDist = dist;
      closestIdx = point.idx;
    }
  });

  if (closestDist <= 8) {
    const checkbox = document.querySelector(`.rowCheckbox[data-idx="${closestIdx}"]`);
    if (checkbox) {
      checkbox.checked = !checkbox.checked;
      updateSelectedCount();
      updateScatterPlot();
    }
  }
});

document.getElementById("scatterPlot").addEventListener("dblclick", (e) => {
  const canvas = document.getElementById("scatterPlot");
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let closestPoint = null;
  let closestDist = Infinity;
  
  Object.entries(pointMap).forEach(([_, point]) => {
    const dist = Math.sqrt(Math.pow(mx - point.x, 2) + Math.pow(my - point.y, 2));
    if (dist < closestDist) {
      closestDist = dist;
      closestPoint = point;
    }
  });

  if (closestDist <= 10 && closestPoint) {
    selectNeighbors(closestPoint.csvRowIdx);
  }
});

document.getElementById("scatterPlot").addEventListener("mousemove", (e) => {
  const canvas = document.getElementById("scatterPlot");
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let foundIdx = null;
  let foundPoint = null;
  let closestDist = Infinity;

  Object.entries(pointMap).forEach(([idx, point]) => {
    const dist = Math.sqrt(Math.pow(mx - point.x, 2) + Math.pow(my - point.y, 2));
    if (dist < closestDist) {
      closestDist = dist;
      if (dist <= 10) {
        foundIdx = parseInt(idx);
        foundPoint = point;
      }
    }
  });

  if (foundIdx !== hoveredPointIdx) {
    hoveredPointIdx = foundIdx;
    renderScatterPlot();
  }

  const tooltip = document.getElementById("scatterTooltip");
  if (foundPoint && closestDist <= 10) {
    tooltip.textContent = `${foundPoint.title} ‚Ä¢ ${foundPoint.artist} (double-click to find neighbors)`;
    tooltip.style.display = "block";
    
    let tooltipX = e.clientX + 12;
    let tooltipY = e.clientY - 20;
    tooltipX = Math.max(0, Math.min(tooltipX, window.innerWidth - 250));
    tooltipY = Math.max(0, tooltipY);
    
    tooltip.style.left = tooltipX + "px";
    tooltip.style.top = tooltipY + "px";
  } else {
    tooltip.style.display = "none";
  }
});

document.getElementById("scatterPlot").addEventListener("mouseleave", () => {
  hoveredPointIdx = null;
  document.getElementById("scatterTooltip").style.display = "none";
  renderScatterPlot();
});

// Settings event listeners
document.getElementById("knnK").addEventListener("change", (e) => {
  const val = parseInt(e.target.value);
  if (val >= 1 && val <= 50) {
    knnSettings.k = val;
    log(`KNN k set to ${val}`, "ok");
  }
});

["BPM", "Energy", "Dance", "Valence"].forEach(dim => {
  const checkbox = document.getElementById(`knnDim-${dim}`);
  // Ensure checkbox reflects current knnSettings state
  checkbox.checked = knnSettings.dimensions[dim];
  
  checkbox.addEventListener("change", (e) => {
    knnSettings.dimensions[dim] = e.target.checked;
    const active = Object.values(knnSettings.dimensions).filter(Boolean).length;
    if (active === 0) {
      log("Warning: At least one dimension must be enabled.", "err");
      e.target.checked = true;
      checkbox.checked = true;
      knnSettings.dimensions[dim] = true;
    } else {
      log(`${dim} ${e.target.checked ? "enabled" : "disabled"}`, "ok");
    }
  });
});

(async function init() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get("code");
  const error = params.get("error");
  
  if (error) { 
    log(`Auth error: ${error}`, "err"); 
  }
  
  if (code) {
    try {
      log("Exchanging authorization code for access token‚Ä¶");
      await exchangeCodeForToken(code);
      window.history.replaceState({}, document.title, window.location.pathname);
      setAuthStatus("‚úì Logged in");
      document.getElementById("createPlaylistBtn").disabled = false;
      log("Logged in successfully!", "ok");
    } catch (e) {
      log(`Token exchange failed: ${e.message}`, "err");
    }
  } else if (localStorage.getItem("access_token")) {
    setAuthStatus("‚úì Logged in");
    document.getElementById("createPlaylistBtn").disabled = false;
    log("Token present.", "ok");
  } else {
    setAuthStatus("Not logged in");
    log("CSV features work without login. Log in to create playlists.", "");
  }
})();
</script>
</body>
</html>